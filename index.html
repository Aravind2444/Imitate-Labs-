<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centered Image</title>
    <style>
        body {
            background-color: black;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .hero-section {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background-color: black;
            opacity: 0;
            transition: opacity 1s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            z-index: 2;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        .centered-image {
            width: 300px;
            height: auto;
            transition: transform 3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: autoScale 6s ease-in-out forwards;
            animation-delay: 1s;
        }
        
        @keyframes autoScale {
            0% {
                transform: scale(1) rotate(0deg);
            }
            100% {
                transform: scale(12) rotate(90deg);
            }
        }
        
        .overlay {
            animation: fadeToBlack 6s ease-in-out forwards;
            animation-delay: 1s;
        }
        
        @keyframes fadeToBlack {
            0% {
                opacity: 0;
            }
            60% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        
        .blur-text-container {
            animation: showText 2s ease-out forwards;
            animation-delay: 5s;
        }
        
        @keyframes showText {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        
        .blur-text-container span {
            opacity: 0;
            transform: translateY(20px);
            filter: blur(10px);
            animation: showChar 0.5s ease-out forwards;
        }
        
        .blur-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            opacity: 0;
            color: white;
            font-size: 2.5rem;
            font-family: Arial, sans-serif;
            font-weight: 600;
            text-align: center;
            max-width: 80%;
            line-height: 1.2;
        }
        
        @keyframes showChar {
            0% {
                opacity: 0;
                transform: translateY(20px);
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
                filter: blur(0);
            }
        }
        
        .dark-veil {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 4;
            opacity: 0;
            animation: showDarkVeil 1s ease-out forwards;
            animation-delay: 10s;
        }
        
        @keyframes showDarkVeil {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        
        .dark-veil canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .dark-veil-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 0;
            z-index: 5;
            pointer-events: none;
        }
        
        .dark-veil-text-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .dark-veil-text {
            font-size: 4rem;
            font-family: Arial, sans-serif;
            font-weight: 700;
            color: white;
            opacity: 0;
            animation: showDarkVeilContent 1s ease-out forwards;
            animation-delay: 11s;
        }
        
        .dark-veil-tagline {
            font-size: 1.2rem;
            font-family: Arial, sans-serif;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
            opacity: 0;
            animation: showDarkVeilContent 1s ease-out forwards;
            animation-delay: 11.5s;
        }
        
        .dark-veil-logo {
            width: 250px;
            height: auto;
            opacity: 0;
            animation: showDarkVeilContent 1s ease-out forwards;
            animation-delay: 11s;
        }
        
        @keyframes showDarkVeilContent {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Glass Surface Navigation */
        .glass-nav {
            position: absolute;
            top: 30px;
            left: 5%;
            transform: none;
            width: 90vw;
            height: 60px;
            border-radius: 30px;
            z-index: 6;
            opacity: 0;
            animation: showDarkVeilContent 1s ease-out forwards;
            animation-delay: 12s;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(4px) saturate(1.1) brightness(1.02);
            border: 1px solid rgba(255, 255, 255, 0.03);
            box-shadow: 
                inset 0 1px 0 0 rgba(255, 255, 255, 0.05),
                0 2px 8px 0 rgba(0, 0, 0, 0.05);
        }
        
        .glass-nav-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 60px;
            padding: 0 40px;
            border-radius: inherit;
        }
        
        .glass-nav-item {
            color: white;
            text-decoration: none;
            font-family: Arial, sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s ease;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.02);
            cursor: pointer;
        }
        
        .glass-nav-item:hover {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            transform: scale(1.05);
            backdrop-filter: blur(3px);
        }
        
        .glass-nav-item:last-child {
            margin-right: 50px;
        }
        
        /* Page Sections */
        .page-section {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.9));
            backdrop-filter: blur(10px);
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            padding: 120px 40px 40px 40px;
            box-sizing: border-box;
        }
        
        .page-section.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        
        .page-content {
            max-width: 1200px;
            margin: 0 auto;
            color: white;
            opacity: 0;
            transform: translateX(50px);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1) 0.3s;
        }
        
        .page-section.active .page-content {
            opacity: 1;
            transform: translateX(0);
        }
        
        .page-title {
            font-size: 3.5rem;
            font-family: Arial, sans-serif;
            font-weight: 700;
            margin-bottom: 30px;
            text-align: center;
            background: linear-gradient(45deg, #fff, #e0c3fc, #9bb5ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .page-text {
            font-size: 1.2rem;
            font-family: Arial, sans-serif;
            font-weight: 400;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 30px;
            text-align: left;
        }
        
        .close-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 50px;
            height: 50px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            opacity: 0;
            transform: translateX(50px);
        }
        
        .page-section.active .close-btn {
            opacity: 1;
            transform: translateX(0);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1) 0.4s;
        }
        
        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 40px;
            padding: 20px;
            position: relative;
        }
        
        .feature-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(132, 0, 255, 0.2);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateX(30px);
            position: relative;
            overflow: hidden;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
            
            /* Glow effect variables */
            --glow-x: 50%;
            --glow-y: 50%;
            --glow-intensity: 0;
            --glow-radius: 300px;
        }
        
        .page-section.active .feature-card {
            opacity: 1;
            transform: translateX(0);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .page-section.active .feature-card:nth-child(1) { transition-delay: 0.4s; }
        .page-section.active .feature-card:nth-child(2) { transition-delay: 0.5s; }
        .page-section.active .feature-card:nth-child(3) { transition-delay: 0.6s; }
        .page-section.active .feature-card:nth-child(4) { transition-delay: 0.7s; }
        .page-section.active .feature-card:nth-child(5) { transition-delay: 0.8s; }
        .page-section.active .feature-card:nth-child(6) { transition-delay: 0.9s; }
        
        .feature-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(132, 0, 255, 0.4);
            box-shadow: 0 8px 32px rgba(132, 0, 255, 0.2);
        }
        
        /* Border glow effect */
        .feature-card::after {
            content: '';
            position: absolute;
            inset: 0;
            padding: 2px;
            background: radial-gradient(var(--glow-radius) circle at var(--glow-x) var(--glow-y),
                rgba(132, 0, 255, calc(var(--glow-intensity) * 0.8)) 0%,
                rgba(132, 0, 255, calc(var(--glow-intensity) * 0.4)) 30%,
                transparent 60%);
            border-radius: inherit;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: subtract;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1;
        }
        
        .feature-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #e0c3fc;
            position: relative;
            z-index: 2;
        }
        
        .feature-description {
            font-size: 1rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            z-index: 2;
        }
        
        /* Particle styles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(132, 0, 255, 1);
            box-shadow: 0 0 6px rgba(132, 0, 255, 0.6);
            pointer-events: none;
            z-index: 100;
        }
        
        /* Global spotlight */
        .global-spotlight {
            position: fixed;
            width: 800px;
            height: 800px;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle,
                rgba(132, 0, 255, 0.15) 0%,
                rgba(132, 0, 255, 0.08) 15%,
                rgba(132, 0, 255, 0.04) 25%,
                rgba(132, 0, 255, 0.02) 40%,
                rgba(132, 0, 255, 0.01) 65%,
                transparent 70%
            );
            z-index: 200;
            opacity: 0;
            transform: translate(-50%, -50%);
            mix-blend-mode: screen;
        }
    </style>
</head>
<body>
    <div class="hero-section">
        <div class="overlay"></div>
        <div class="container">
            <img src="Group 6.png" alt="Group 6" class="centered-image">
        </div>
        <div class="blur-text-container" id="blur-text-container"></div>
    </div>
    
    <div class="dark-veil" id="dark-veil">
        <canvas id="dark-veil-canvas"></canvas>
        <nav class="glass-nav">
            <div class="glass-nav-content">
                <a href="#" class="glass-nav-item" onclick="showPage('about')">About</a>
                <a href="#" class="glass-nav-item" onclick="showPage('features')">Feature</a>
                <a href="#" class="glass-nav-item">Contact</a>
            </div>
        </nav>
        <div class="dark-veil-content">
            <div class="dark-veil-text-container">
                <div class="dark-veil-text">Imitate Labs</div>
                <div class="dark-veil-tagline">Empowering seamless video edits in the style you love</div>
            </div>
            <img src="Group 6.png" alt="Group 6" class="dark-veil-logo">
        </div>
    </div>
    
    <!-- About Page -->
    <div id="about-page" class="page-section">
        <button class="close-btn" onclick="closePage()">&times;</button>
        <div class="page-content">
            <h1 class="page-title">About Imitate Labs</h1>
            <div class="page-text">
                <p>Imitate Labs is not just a platform. It is an AI agent. While a platform gives users tools, an agent acts on their behalf.</p>
                
                <p>They'll say, "Edit this like Emma Chamberlain with casual pacing, jump cuts, and vlog-style text," and the agent will learn the style, analyze the footage, and deliver a fully edited video, thumbnail, and title all autonomously.</p>
                
                <p>Post MVP, no reference will even be needed. Through peer group mapping, the AI understands how the end user would like the video to be edited simply by saying "edit this video."</p>
                
                <p>The platform is just the interface. The real magic is the intelligent agent doing the heavy lifting. We are not building another editing tool. We are building a smart, scalable editor in the cloud.</p>
            </div>
        </div>
    </div>
    
    <!-- Features Page -->
    <div id="features-page" class="page-section">
        <button class="close-btn" onclick="closePage()">&times;</button>
        <div class="page-content">
            <h1 class="page-title">Features</h1>
            <div class="page-text">
                <p>Experience the future of video editing with our intelligent AI agent that transforms your creative vision into reality.</p>
            </div>
            
            <div class="feature-grid">
                <div class="feature-card">
                    <h3 class="feature-title">AI-Powered Style Recognition</h3>
                    <p class="feature-description">Simply describe your desired editing style or reference a creator, and our AI agent learns and applies those techniques to your footage automatically.</p>
                </div>
                
                <div class="feature-card">
                    <h3 class="feature-title">Autonomous Video Production</h3>
                    <p class="feature-description">From raw footage to final product - our agent delivers fully edited videos, custom thumbnails, and optimized titles without manual intervention.</p>
                </div>
                
                <div class="feature-card">
                    <h3 class="feature-title">Cloud-Based Intelligence</h3>
                    <p class="feature-description">Powered by scalable cloud infrastructure, ensuring fast processing and continuous learning from global editing patterns and trends.</p>
                </div>
                
                <div class="feature-card">
                    <h3 class="feature-title">Peer Group Mapping</h3>
                    <p class="feature-description">Advanced algorithms understand your target audience and editing preferences through intelligent peer group analysis and behavior mapping.</p>
                </div>
                
                <div class="feature-card">
                    <h3 class="feature-title">Natural Language Processing</h3>
                    <p class="feature-description">Communicate your vision in plain English. Our AI understands creative direction like "casual pacing," "jump cuts," and "vlog-style text."</p>
                </div>
                
                <div class="feature-card">
                    <h3 class="feature-title">Smart Content Analysis</h3>
                    <p class="feature-description">Intelligent footage analysis identifies key moments, emotions, and narrative elements to create compelling edits that resonate with viewers.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Create the blur text element
        const blurTextContainer = document.getElementById('blur-text-container');
        const text = "Empowering seamless video edits in the style you love";
        
        // Split by words and create spans for each character
        text.split(' ').forEach((word, wordIndex) => {
            word.split('').forEach((char, charIndex) => {
                const span = document.createElement('span');
                span.textContent = char;
                span.style.display = 'inline-block';
                // Set animation delay for staggered effect
                const totalDelay = (wordIndex * 5 + charIndex) * 0.1;
                span.style.animationDelay = `${5 + totalDelay}s`;
                blurTextContainer.appendChild(span);
            });
            if (wordIndex < text.split(' ').length - 1) {
                blurTextContainer.appendChild(document.createTextNode(' '));
            }
        });
        
        // WebGL Dark Veil Effect
        class DarkVeil {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                this.startTime = performance.now();
                this.frame = null;
                
                // Options with defaults
                this.hueShift = options.hueShift || 0;
                this.noiseIntensity = options.noiseIntensity || 0.02;
                this.scanlineIntensity = options.scanlineIntensity || 0.1;
                this.speed = options.speed || 0.5;
                this.scanlineFrequency = options.scanlineFrequency || 0.02;
                this.warpAmount = options.warpAmount || 0.1;
                
                if (!this.gl) {
                    console.error('WebGL not supported');
                    return;
                }
                
                this.setupShaders();
                this.setupGeometry();
                this.resize();
                this.start();
                
                window.addEventListener('resize', () => this.resize());
            }
            
            setupShaders() {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, `
                    attribute vec2 position;
                    void main(){gl_Position=vec4(position,0.0,1.0);}
                `);
                
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `
                    #ifdef GL_ES
                    precision lowp float;
                    #endif
                    uniform vec2 uResolution;
                    uniform float uTime;
                    uniform float uHueShift;
                    uniform float uNoise;
                    uniform float uScan;
                    uniform float uScanFreq;
                    uniform float uWarp;
                    #define iTime uTime
                    #define iResolution uResolution

                    vec4 buf[8];
                    float rand(vec2 c){return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453);}

                    mat3 rgb2yiq=mat3(0.299,0.587,0.114,0.596,-0.274,-0.322,0.211,-0.523,0.312);
                    mat3 yiq2rgb=mat3(1.0,0.956,0.621,1.0,-0.272,-0.647,1.0,-1.106,1.703);

                    vec3 hueShiftRGB(vec3 col,float deg){
                        vec3 yiq=rgb2yiq*col;
                        float rad=radians(deg);
                        float cosh=cos(rad),sinh=sin(rad);
                        vec3 yiqShift=vec3(yiq.x,yiq.y*cosh-yiq.z*sinh,yiq.y*sinh+yiq.z*cosh);
                        return clamp(yiq2rgb*yiqShift,0.0,1.0);
                    }

                    vec4 sigmoid(vec4 x){return 1./(1.+exp(-x));}

                    vec4 cppn_fn(vec2 coordinate,float in0,float in1,float in2){
                        buf[6]=vec4(coordinate.x,coordinate.y,0.3948333106474662+in0,0.36+in1);
                        buf[7]=vec4(0.14+in2,sqrt(coordinate.x*coordinate.x+coordinate.y*coordinate.y),0.,0.);
                        buf[0]=mat4(vec4(6.5404263,-3.6126034,0.7590882,-1.13613),vec4(2.4582713,3.1660357,1.2219609,0.06276096),vec4(-5.478085,-6.159632,1.8701609,-4.7742867),vec4(6.039214,-5.542865,-0.90925294,3.251348))*buf[6]+mat4(vec4(0.8473259,-5.722911,3.975766,1.6522468),vec4(-0.24321538,0.5839259,-1.7661959,-5.350116),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(0.21808943,1.1243913,-1.7969975,5.0294676);
                        buf[1]=mat4(vec4(-3.3522482,-6.0612736,0.55641043,-4.4719114),vec4(0.8631464,1.7432913,5.643898,1.6106541),vec4(2.4941394,-3.5012043,1.7184316,6.357333),vec4(3.310376,8.209261,1.1355612,-1.165539))*buf[6]+mat4(vec4(5.24046,-13.034365,0.009859298,15.870829),vec4(2.987511,3.129433,-0.89023495,-1.6822904),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-5.9457836,-6.573602,-0.8812491,1.5436668);
                        buf[0]=sigmoid(buf[0]);buf[1]=sigmoid(buf[1]);
                        buf[2]=mat4(vec4(-15.219568,8.095543,-2.429353,-1.9381982),vec4(-5.951362,4.3115187,2.6393783,1.274315),vec4(-7.3145227,6.7297835,5.2473326,5.9411426),vec4(5.0796127,8.979051,-1.7278991,-1.158976))*buf[6]+mat4(vec4(-11.967154,-11.608155,6.1486754,11.237008),vec4(2.124141,-6.263192,-1.7050359,-0.7021966),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-4.17164,-3.2281182,-4.576417,-3.6401186);
                        buf[3]=mat4(vec4(3.1832156,-13.738922,1.879223,3.233465),vec4(0.64300746,12.768129,1.9141049,0.50990224),vec4(-0.049295485,4.4807224,1.4733979,1.801449),vec4(5.0039253,13.000481,3.3991797,-4.5561905))*buf[6]+mat4(vec4(-0.1285731,7.720628,-3.1425676,4.742367),vec4(0.6393625,3.714393,-0.8108378,-0.39174938),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.))*buf[7]+vec4(-1.1811101,-21.621881,0.7851888,1.2329718);
                        buf[2]=sigmoid(buf[2]);buf[3]=sigmoid(buf[3]);
                        buf[4]=mat4(vec4(5.214916,-7.183024,2.7228765,2.6592617),vec4(-5.601878,-25.3591,4.067988,0.4602802),vec4(-10.57759,24.286327,21.102104,37.546658),vec4(4.3024497,-1.9625226,2.3458803,-1.372816))*buf[0]+mat4(vec4(-17.6526,-10.507558,2.2587414,12.462782),vec4(6.265566,-502.75443,-12.642513,0.9112289),vec4(-10.983244,20.741234,-9.701768,-0.7635988),vec4(5.383626,1.4819539,-4.1911616,-4.8444734))*buf[1]+mat4(vec4(12.785233,-16.345072,-0.39901125,1.7955981),vec4(-30.48365,-1.8345358,1.4542528,-1.1118771),vec4(19.872723,-7.337935,-42.941723,-98.52709),vec4(8.337645,-2.7312303,-2.2927687,-36.142323))*buf[2]+mat4(vec4(-16.298317,3.5471997,-0.44300047,-9.444417),vec4(57.5077,-35.609753,16.163465,-4.1534753),vec4(-0.07470326,-3.8656476,-7.0901804,3.1523974),vec4(-12.559385,-7.077619,1.490437,-0.8211543))*buf[3]+vec4(-7.67914,15.927437,1.3207729,-1.6686112);
                        buf[5]=mat4(vec4(-1.4109162,-0.372762,-3.770383,-21.367174),vec4(-6.2103205,-9.35908,0.92529047,8.82561),vec4(11.460242,-22.348068,13.625772,-18.693201),vec4(-0.3429052,-3.9905605,-2.4626114,-0.45033523))*buf[0]+mat4(vec4(7.3481627,-4.3661838,-6.3037653,-3.868115),vec4(1.5462853,6.5488915,1.9701879,-0.58291394),vec4(6.5858274,-2.2180402,3.7127688,-1.3730392),vec4(-5.7973905,10.134961,-2.3395722,-5.965605))*buf[1]+mat4(vec4(-2.5132585,-6.6685553,-1.4029363,-0.16285264),vec4(-0.37908727,0.53738135,4.389061,-1.3024765),vec4(-0.70647055,2.0111287,-5.1659346,-3.728635),vec4(-13.562562,10.487719,-0.9173751,-2.6487076))*buf[2]+mat4(vec4(-8.645013,6.5546675,-6.3944063,-5.5933375),vec4(-0.57783127,-1.077275,36.91025,5.736769),vec4(14.283112,3.7146652,7.1452246,-4.5958776),vec4(2.7192075,3.6021907,-4.366337,-2.3653464))*buf[3]+vec4(-5.9000807,-4.329569,1.2427121,8.59503);
                        buf[4]=sigmoid(buf[4]);buf[5]=sigmoid(buf[5]);
                        buf[6]=mat4(vec4(-1.61102,0.7970257,1.4675229,0.20917463),vec4(-28.793737,-7.1390953,1.5025433,4.656581),vec4(-10.94861,39.66238,0.74318546,-10.095605),vec4(-0.7229728,-1.5483948,0.7301322,2.1687684))*buf[0]+mat4(vec4(3.2547753,21.489103,-1.0194173,-3.3100595),vec4(-3.7316632,-3.3792162,-7.223193,-0.23685838),vec4(13.1804495,0.7916005,5.338587,5.687114),vec4(-4.167605,-17.798311,-6.815736,-1.6451967))*buf[1]+mat4(vec4(0.604885,-7.800309,-7.213122,-2.741014),vec4(-3.522382,-0.12359311,-0.5258442,0.43852118),vec4(9.6752825,-22.853785,2.062431,0.099892326),vec4(-4.3196306,-17.730087,2.5184598,5.30267))*buf[2]+mat4(vec4(-6.545563,-15.790176,-6.0438633,-5.415399),vec4(-43.591583,28.551912,-16.00161,18.84728),vec4(4.212382,8.394307,3.0958717,8.657522),vec4(-5.0237565,-4.450633,-4.4768,-5.5010443))*buf[3]+mat4(vec4(1.6985557,-67.05806,6.897715,1.9004834),vec4(1.8680354,2.3915145,2.5231109,4.081538),vec4(11.158006,1.7294737,2.0738268,7.386411),vec4(-4.256034,-306.24686,8.258898,-17.132736))*buf[4]+mat4(vec4(1.6889864,-4.5852966,3.8534803,-6.3482175),vec4(1.3543309,-1.2640043,9.932754,2.9079645),vec4(-5.2770967,0.07150358,-0.13962056,3.3269649),vec4(28.34703,-4.918278,6.1044083,4.085355))*buf[5]+vec4(6.6818056,12.522166,-3.7075126,-4.104386);
                        buf[7]=mat4(vec4(-8.265602,-4.7027016,5.098234,0.7509808),vec4(8.6507845,-17.15949,16.51939,-8.884479),vec4(-4.036479,-2.3946867,-2.6055532,-1.9866527),vec4(-2.2167742,-1.8135649,-5.9759874,4.8846445))*buf[0]+mat4(vec4(6.7790847,3.5076547,-2.8191125,-2.7028968),vec4(-5.743024,-0.27844876,1.4958696,-5.0517144),vec4(13.122226,15.735168,-2.9397483,-4.101023),vec4(-14.375265,-5.030483,-6.2599335,2.9848232))*buf[1]+mat4(vec4(4.0950394,-0.94011575,-5.674733,4.755022),vec4(4.3809423,4.8310084,1.7425908,-3.437416),vec4(2.117492,0.16342592,-104.56341,16.949184),vec4(-5.22543,-2.994248,3.8350096,-1.9364246))*buf[2]+mat4(vec4(-5.900337,1.7946124,-13.604192,-3.8060522),vec4(6.6583457,31.911177,25.164474,91.81147),vec4(11.840538,4.1503043,-0.7314397,6.768467),vec4(-6.3967767,4.034772,6.1714606,-0.32874924))*buf[3]+mat4(vec4(3.4992442,-196.91893,-8.923708,2.8142626),vec4(3.4806502,-3.1846354,5.1725626,5.1804223),vec4(-2.4009497,15.585794,1.2863957,2.0252278),vec4(-71.25271,-62.441242,-8.138444,0.50670296))*buf[4]+mat4(vec4(-12.291733,-11.176166,-7.3474145,4.390294),vec4(10.805477,5.6337385,-0.9385842,-4.7348723),vec4(-12.869276,-7.039391,5.3029537,7.5436664),vec4(1.4593618,8.91898,3.5101583,5.840625))*buf[5]+vec4(2.2415268,-6.705987,-0.98861027,-2.117676);
                        buf[6]=sigmoid(buf[6]);buf[7]=sigmoid(buf[7]);
                        buf[0]=mat4(vec4(1.6794263,1.3817469,2.9625452,0.),vec4(-1.8834411,-1.4806935,-3.5924516,0.),vec4(-1.3279216,-1.0918057,-2.3124623,0.),vec4(0.2662234,0.23235129,0.44178495,0.))*buf[0]+mat4(vec4(-0.6299101,-0.5945583,-0.9125601,0.),vec4(0.17828953,0.18300213,0.18182953,0.),vec4(-2.96544,-2.5819945,-4.9001055,0.),vec4(1.4195864,1.1868085,2.5176322,0.))*buf[1]+mat4(vec4(-1.2584374,-1.0552157,-2.1688404,0.),vec4(-0.7200217,-0.52666044,-1.438251,0.),vec4(0.15345335,0.15196142,0.272854,0.),vec4(0.945728,0.8861938,1.2766753,0.))*buf[2]+mat4(vec4(-2.4218085,-1.968602,-4.35166,0.),vec4(-22.683098,-18.0544,-41.954372,0.),vec4(0.63792,0.5470648,1.1078634,0.),vec4(-1.5489894,-1.3075932,-2.6444845,0.))*buf[3]+mat4(vec4(-0.49252132,-0.39877754,-0.91366625,0.),vec4(0.95609266,0.7923952,1.640221,0.),vec4(0.30616966,0.15693925,0.8639857,0.),vec4(1.1825981,0.94504964,2.176963,0.))*buf[4]+mat4(vec4(0.35446745,0.3293795,0.59547555,0.),vec4(-0.58784515,-0.48177817,-1.0614829,0.),vec4(2.5271258,1.9991658,4.6846647,0.),vec4(0.13042648,0.08864098,0.30187556,0.))*buf[5]+mat4(vec4(-1.7718065,-1.4033192,-3.3355875,0.),vec4(3.1664357,2.638297,5.378702,0.),vec4(-3.1724713,-2.6107926,-5.549295,0.),vec4(-2.851368,-2.249092,-5.3013067,0.))*buf[6]+mat4(vec4(1.5203838,1.2212278,2.8404984,0.),vec4(1.5210563,1.2651345,2.683903,0.),vec4(2.9789467,2.4364579,5.2347264,0.),vec4(2.2270417,1.8825914,3.8028636,0.))*buf[7]+vec4(-1.5468478,-3.6171484,0.24762098,0.);
                        buf[0]=sigmoid(buf[0]);
                        return vec4(buf[0].x,buf[0].y,buf[0].z,1.);
                    }

                    void mainImage(out vec4 fragColor,in vec2 fragCoord){
                        vec2 uv=fragCoord/uResolution.xy*2.-1.;
                        uv.y*=-1.;
                        uv+=uWarp*vec2(sin(uv.y*6.283+uTime*0.5),cos(uv.x*6.283+uTime*0.5))*0.05;
                        fragColor=cppn_fn(uv,0.1*sin(0.3*uTime),0.1*sin(0.69*uTime),0.1*sin(0.44*uTime));
                    }

                    void main(){
                        vec4 col;mainImage(col,gl_FragCoord.xy);
                        col.rgb=hueShiftRGB(col.rgb,uHueShift);
                        
                        // Darken the base color for deeper purple background
                        col.rgb *= 0.3;
                        
                        // Add deep purple base color
                        vec3 deepPurple = vec3(0.08, 0.02, 0.15);
                        col.rgb = mix(deepPurple, col.rgb, 0.7);
                        
                        float scanline_val=sin(gl_FragCoord.y*uScanFreq)*0.5+0.5;
                        col.rgb*=1.-(scanline_val*scanline_val)*uScan;
                        col.rgb+=(rand(gl_FragCoord.xy+uTime)-0.5)*uNoise;
                        gl_FragColor=vec4(clamp(col.rgb,0.0,1.0),1.0);
                    }
                `);
                
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);
                
                this.uniforms = {
                    uTime: this.gl.getUniformLocation(this.program, 'uTime'),
                    uResolution: this.gl.getUniformLocation(this.program, 'uResolution'),
                    uHueShift: this.gl.getUniformLocation(this.program, 'uHueShift'),
                    uNoise: this.gl.getUniformLocation(this.program, 'uNoise'),
                    uScan: this.gl.getUniformLocation(this.program, 'uScan'),
                    uScanFreq: this.gl.getUniformLocation(this.program, 'uScanFreq'),
                    uWarp: this.gl.getUniformLocation(this.program, 'uWarp')
                };
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                return shader;
            }
            
            setupGeometry() {
                const vertices = new Float32Array([
                    -1, -1,
                     3, -1,
                    -1,  3
                ]);
                
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                this.positionLocation = this.gl.getAttribLocation(this.program, 'position');
            }
            
            resize() {
                const parent = this.canvas.parentElement;
                const w = parent.clientWidth;
                const h = parent.clientHeight;
                
                this.canvas.width = w;
                this.canvas.height = h;
                this.gl.viewport(0, 0, w, h);
            }
            
            start() {
                const render = () => {
                    const time = (performance.now() - this.startTime) / 1000 * this.speed;
                    
                    this.gl.useProgram(this.program);
                    
                    this.gl.uniform1f(this.uniforms.uTime, time);
                    this.gl.uniform2f(this.uniforms.uResolution, this.canvas.width, this.canvas.height);
                    this.gl.uniform1f(this.uniforms.uHueShift, this.hueShift + Math.sin(time * 0.1) * 15);
                    this.gl.uniform1f(this.uniforms.uNoise, this.noiseIntensity);
                    this.gl.uniform1f(this.uniforms.uScan, this.scanlineIntensity);
                    this.gl.uniform1f(this.uniforms.uScanFreq, this.scanlineFrequency);
                    this.gl.uniform1f(this.uniforms.uWarp, this.warpAmount);
                    
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                    this.gl.enableVertexAttribArray(this.positionLocation);
                    this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
                    
                    this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
                    
                    this.frame = requestAnimationFrame(render);
                };
                
                render();
            }
            
            destroy() {
                if (this.frame) {
                    cancelAnimationFrame(this.frame);
                }
            }
        }
        
        // Initialize Dark Veil 2 seconds after text animation finishes (around 8s)
        setTimeout(() => {
            const canvas = document.getElementById('dark-veil-canvas');
            new DarkVeil(canvas, {
                hueShift: 270,
                noiseIntensity: 0.02,
                scanlineIntensity: 0.1,
                speed: 1.5,
                scanlineFrequency: 0.02,
                warpAmount: 0.1
            });
        }, 10000);
        
        // MagicBento functionality
        class MagicBentoEffects {
            constructor() {
                this.glowColor = '132, 0, 255';
                this.particleCount = 8;
                this.spotlightRadius = 300;
                this.activeParticles = new Map();
                this.animationTimeouts = new Map();
                this.spotlight = null;
                this.isInsideFeatures = false;
                
                this.initSpotlight();
                this.bindEvents();
            }
            
            initSpotlight() {
                this.spotlight = document.createElement('div');
                this.spotlight.className = 'global-spotlight';
                document.body.appendChild(this.spotlight);
            }
            
            createParticle(x, y) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                return particle;
            }
            
            animateParticles(card) {
                const cardId = card.dataset.cardId || Math.random().toString();
                card.dataset.cardId = cardId;
                
                if (this.activeParticles.has(cardId)) return;
                
                const rect = card.getBoundingClientRect();
                const particles = [];
                
                for (let i = 0; i < this.particleCount; i++) {
                    const particle = this.createParticle(
                        Math.random() * rect.width,
                        Math.random() * rect.height
                    );
                    
                    card.appendChild(particle);
                    particles.push(particle);
                    
                    // Animate particle
                    const animation = particle.animate([
                        { 
                            transform: 'scale(0) rotate(0deg)', 
                            opacity: 0 
                        },
                        { 
                            transform: 'scale(1) rotate(180deg)', 
                            opacity: 1 
                        },
                        { 
                            transform: `scale(1) rotate(360deg) translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px)`, 
                            opacity: 0.3 
                        }
                    ], {
                        duration: 2000 + Math.random() * 1000,
                        iterations: Infinity,
                        direction: 'alternate'
                    });
                    
                    // Opacity animation
                    const opacityAnimation = particle.animate([
                        { opacity: 0.3 },
                        { opacity: 1 },
                        { opacity: 0.3 }
                    ], {
                        duration: 1500,
                        iterations: Infinity,
                        direction: 'alternate'
                    });
                }
                
                this.activeParticles.set(cardId, particles);
            }
            
            clearParticles(card) {
                const cardId = card.dataset.cardId;
                if (!cardId || !this.activeParticles.has(cardId)) return;
                
                const particles = this.activeParticles.get(cardId);
                particles.forEach(particle => {
                    particle.animate([
                        { transform: 'scale(1)', opacity: particle.style.opacity || 1 },
                        { transform: 'scale(0)', opacity: 0 }
                    ], {
                        duration: 300,
                        fill: 'forwards'
                    }).onfinish = () => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    };
                });
                
                this.activeParticles.delete(cardId);
            }
            
            updateCardGlow(card, mouseX, mouseY, intensity) {
                const rect = card.getBoundingClientRect();
                const relativeX = ((mouseX - rect.left) / rect.width) * 100;
                const relativeY = ((mouseY - rect.top) / rect.height) * 100;
                
                card.style.setProperty('--glow-x', `${relativeX}%`);
                card.style.setProperty('--glow-y', `${relativeY}%`);
                card.style.setProperty('--glow-intensity', intensity.toString());
            }
            
            handleCardMouseEnter(card) {
                this.animateParticles(card);
                
                // Tilt effect
                card.style.transform = 'perspective(1000px) rotateX(5deg) rotateY(5deg) translateY(-5px)';
            }
            
            handleCardMouseLeave(card) {
                this.clearParticles(card);
                
                // Reset transforms
                card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateY(0px)';
                card.style.setProperty('--glow-intensity', '0');
            }
            
            handleCardMouseMove(card, e) {
                const rect = card.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Tilt effect
                const rotateX = ((y - centerY) / centerY) * -10;
                const rotateY = ((x - centerX) / centerX) * 10;
                
                // Magnetism effect
                const magnetX = (x - centerX) * 0.05;
                const magnetY = (y - centerY) * 0.05;
                
                card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translate(${magnetX}px, ${magnetY}px) translateY(-5px)`;
            }
            
            handleCardClick(card, e) {
                const rect = card.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const maxDistance = Math.max(
                    Math.hypot(x, y),
                    Math.hypot(x - rect.width, y),
                    Math.hypot(x, y - rect.height),
                    Math.hypot(x - rect.width, y - rect.height)
                );
                
                const ripple = document.createElement('div');
                ripple.style.cssText = `
                    position: absolute;
                    width: ${maxDistance * 2}px;
                    height: ${maxDistance * 2}px;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(${this.glowColor}, 0.4) 0%, rgba(${this.glowColor}, 0.2) 30%, transparent 70%);
                    left: ${x - maxDistance}px;
                    top: ${y - maxDistance}px;
                    pointer-events: none;
                    z-index: 1000;
                `;
                
                card.appendChild(ripple);
                
                ripple.animate([
                    { transform: 'scale(0)', opacity: 1 },
                    { transform: 'scale(1)', opacity: 0 }
                ], {
                    duration: 800,
                    easing: 'ease-out'
                }).onfinish = () => {
                    if (ripple.parentNode) {
                        ripple.parentNode.removeChild(ripple);
                    }
                };
            }
            
            handleGlobalMouseMove(e) {
                const featuresPage = document.getElementById('features-page');
                if (!featuresPage || !featuresPage.classList.contains('active')) {
                    this.spotlight.style.opacity = '0';
                    return;
                }
                
                const featureCards = featuresPage.querySelectorAll('.feature-card');
                let minDistance = Infinity;
                let insideAnyCard = false;
                
                featureCards.forEach(card => {
                    const rect = card.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const distance = Math.hypot(e.clientX - centerX, e.clientY - centerY) - Math.max(rect.width, rect.height) / 2;
                    const effectiveDistance = Math.max(0, distance);
                    
                    minDistance = Math.min(minDistance, effectiveDistance);
                    
                    const proximity = this.spotlightRadius * 0.5;
                    const fadeDistance = this.spotlightRadius * 0.75;
                    
                    let glowIntensity = 0;
                    if (effectiveDistance <= proximity) {
                        glowIntensity = 1;
                        insideAnyCard = true;
                    } else if (effectiveDistance <= fadeDistance) {
                        glowIntensity = (fadeDistance - effectiveDistance) / (fadeDistance - proximity);
                        insideAnyCard = true;
                    }
                    
                    this.updateCardGlow(card, e.clientX, e.clientY, glowIntensity);
                });
                
                // Update spotlight
                this.spotlight.style.left = e.clientX + 'px';
                this.spotlight.style.top = e.clientY + 'px';
                
                const proximity = this.spotlightRadius * 0.5;
                const fadeDistance = this.spotlightRadius * 0.75;
                
                let targetOpacity = 0;
                if (minDistance <= proximity) {
                    targetOpacity = 0.8;
                } else if (minDistance <= fadeDistance) {
                    targetOpacity = ((fadeDistance - minDistance) / (fadeDistance - proximity)) * 0.8;
                }
                
                this.spotlight.style.opacity = targetOpacity.toString();
            }
            
            bindEvents() {
                // Global mouse movement for spotlight
                document.addEventListener('mousemove', (e) => this.handleGlobalMouseMove(e));
                
                // Feature card events
                document.addEventListener('mouseenter', (e) => {
                    if (e.target.classList.contains('feature-card')) {
                        this.handleCardMouseEnter(e.target);
                    }
                }, true);
                
                document.addEventListener('mouseleave', (e) => {
                    if (e.target.classList.contains('feature-card')) {
                        this.handleCardMouseLeave(e.target);
                    }
                }, true);
                
                document.addEventListener('mousemove', (e) => {
                    if (e.target.classList.contains('feature-card')) {
                        this.handleCardMouseMove(e.target, e);
                    }
                });
                
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.feature-card')) {
                        this.handleCardClick(e.target.closest('.feature-card'), e);
                    }
                });
                
                // Clean up when leaving features page
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const featureCards = document.querySelectorAll('.feature-card');
                        featureCards.forEach(card => {
                            this.clearParticles(card);
                            card.style.transform = '';
                            card.style.setProperty('--glow-intensity', '0');
                        });
                        this.spotlight.style.opacity = '0';
                    }
                });
            }
        }
        
        // Initialize MagicBento effects when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new MagicBentoEffects();
        });
        
        // No scroll event listener needed - everything is automatic now
        // The animations are handled by CSS keyframes
        
        // Page navigation functions
        function showPage(pageId) {
            const page = document.getElementById(pageId + '-page');
            if (page) {
                page.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closePage() {
            const activePages = document.querySelectorAll('.page-section.active');
            activePages.forEach(page => {
                page.classList.remove('active');
            });
            document.body.style.overflow = 'hidden';
        }
        
        // Close page on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closePage();
            }
        });
    </script>
</body>
</html>
